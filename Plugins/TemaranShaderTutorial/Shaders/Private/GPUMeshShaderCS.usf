
#include "/Engine/Public/Platform.ush"

Texture3D<float4> InputTexture;
RWTexture2D<float4> OutputTexture;
float4 InputTextureSize;
float4 InputSlice;

uint2 pos2texCo(uint3 pos, uint3 textureSize, uint2 slice)
{
	uint z = pos.z;
	uint2 offset;
	offset.x = z / slice.x * textureSize.x;
	offset.y = (z - (z / slice.x) * slice.x) * textureSize.y;
	return offset + pos.xy;
}
[numthreads(THREADGROUPSIZE_X, THREADGROUPSIZE_Y, THREADGROUPSIZE_Z)]
void MainComputeShader(uint3 ThreadId : SV_DispatchThreadID)
{
	uint InputSizeX, InputSizeY, InputSizeZ;
	InputTexture.GetDimensions(InputSizeX,InputSizeY,InputSizeZ);
	if (ThreadId.x >= InputSizeX || ThreadId.y >= InputSizeY || ThreadId.z >= InputSizeZ)
	{
		return;
	}
	float4 data = InputTexture[ThreadId.xyz];
	float sdf = data.x;
	uint2 texCoord = pos2texCo(ThreadId, (uint3)(InputTextureSize.xyz), (uint2)InputSlice.xy);
	uint outputTextureWidth, outputTextureHeight;
	OutputTexture.GetDimensions(outputTextureWidth,outputTextureHeight);

	//sdf = InputTexture[uint3(ThreadId.xy, 60)];
	if (texCoord.x < outputTextureWidth && texCoord.y < outputTextureHeight)
	{
		OutputTexture[texCoord] = float4(sdf,1.0f - sdf,float(texCoord.x) / outputTextureWidth,float(texCoord.y) / outputTextureHeight);
	}
}