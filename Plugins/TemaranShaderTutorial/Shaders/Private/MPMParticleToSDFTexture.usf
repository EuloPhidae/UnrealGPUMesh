#include "/Engine/Public/Platform.ush"
#include "MPMPublic.ush"

RWStructuredBuffer<FParticleData> particleDataBuffer;
RWTexture3D<float4> OutputTexture;

uint n_particles;
uint texture_size;



[numthreads(8, 1, 1)]
void Main(uint3 threadId : SV_DispatchThreadID)
{
	uint p = threadId.x;
	if (p >= n_particles)
	{
		return;
	}
	FParticleData particleData = particleDataBuffer[p];
	float3 pos = particleData.x * (float)texture_size;
	uint3 output_pos = (uint3)pos;
    int sdfSize = 0 ;
    
	
	if (pos.x < 0 || pos.x >=texture_size || pos.y < 0 || pos.y >= texture_size || pos.z < 0 || pos.z >= texture_size)
	{
		return;
	}
	else
	{
		float speed = length(particleData.v);
		const int sdfSize = 7;
		for(int i = -sdfSize; i<sdfSize; i++)
			for(int j = -sdfSize; j < sdfSize; j++)
				for(int k = -sdfSize; k < sdfSize; k++)
				{
					int3 possPos = (int3)pos + int3(i,j,k);
					if (possPos.x < 0 || possPos.x >= texture_size || possPos.y < 0 || possPos.y >= texture_size || possPos.z < 0 || possPos.z >= texture_size)
					{
						continue;;
					}
					if (length(float3(i,j,k)) <= (float)sdfSize)
					{
						OutputTexture[output_pos + uint3(i,j,k)] = float4(1,1,1,1);
					}
				}
					
	}
}